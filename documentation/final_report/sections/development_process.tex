\section{Development Process}
\label{sec:dev_process}
As highlighted in section~\ref{sec:intro} and design document, the key components of this software are geometrical set up (domain and obstacles), algorithm for path finding, solution method and results visualization. The goal of this project was to develop a modular and extensible path find software and the development process was decided based on this goal. The aforementioned tasks were divided amongst the group members, who were responsible for a given set of classes. Git was used for maintaining the collaborative work amongst the members. As tasks were fairly independent, it was important to have unit tests as well as integration tests to make sure that the software was working in a cohesive manner. Evolution of the software required automatic testing applications to make sure new additions did not break it. Along the way, various issues were faced and lesson learned. The whole processes is detailed in the following subsections.
\subsection{Github Repo Setup}
Given the flexibility offered by Git, it is unsurprising that various recipes for collaborative work have emerged over the years. A few common workflow models are:
\begin{enumerate}
	\item \href{https://www.atlassian.com/git/tutorials/comparing-workflows#centralized-workflow}{Centralized Workflow}: Only one branch {\ttfamily master} is used and all the team members commit changes to this branch. This option is however prone to merge conflicts.
	\item \href{https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow}{Feature Branch Workflow}: The core idea behind this approach is that any new feature development takes place on a dedicated branch which means that the {\ttfamily master} branch is never broken. Further this allows for pull requests which help to discuss the code before they are pushed to {\ttfamily master}.
	\item \href{https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow}{Gitflow Workflow}: Popularized by Vincent Drienssen at \href{https://nvie.com/posts/a-successful-git-branching-model/}{nvie} this is used in larger projects which are focused on software release cycles. A {\ttfamily develop} branch is created from {\ttfamily master} which is used to create {\ttfamily feature} and {\ttfamily release} branches. Branch {\ttfamily feature} is merged to {\ttfamily develop}, while {\ttfamily release} is also merged with {\ttfamily master}. It further allows for a {\ttfamily hotfixe} branch to resolve issues with master.
	\item \href{https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow}{Forking Workflow}: Commonly used in open source projects (e.g. \href{https://github.com/dealii/dealii}{DEAL.II}), this model gives each developer their own server-side repository. Only the maintainers of the software have write access to the official code, while giving contributors an option to create pull requests to add features to the open source project.
\end{enumerate}
Since there are only three developers involved in this project who communicated frequently in person, a mix of "Gitflow" and "Feature Branch" workflows was adopted. The rationale being that each one of us is responsible for a given feature and only merges with {\ttfamily development} branch if all the tests pass. One of the members was responsible for integration tests and to merge the {\ttfamily development} with {\ttfamily master}. This was a nice middle ground between the rigorous checks of option 3 and 4, and a complete mayhem that could result from working on master branch directly. The work flow of the software development can be best visualized as shown in the Figure~\ref{fig:git_structure}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{./figures/git_work_flow.pdf}
	\caption{\label{fig:git_structure} Graph demonstrating the git work-flow between the developers}
\end{figure}
\subsection{Writing Tests}
For the purpose of this project, unit tests were written to evaluate the various classes for expected behavior and determining edge cases. The project was not entirely test-driven, i.e. the tests were not written before the code, but rather tests were written along with the creation of new classes as well as whenever the functionality of a class changed. To make sure that the functionality of the software was never compromised, it was mandated that all the tests must pass before the code could be pushed to the {\ttfamily development} branch. The tests had another benefit of informing the team members about the input parameters required and the methods and attributes to expect. This became highly important as the classes evolved and deviated from our initial design proposal. Two different approaches to writing tests were taken by the team members. This was because we did not decide on a preferred method and by the time we caught on there was an inertia to change it. The two approaches were:
\begin{enumerate}
	\item \href{https://docs.python.org/3.6/library/unittest.html#module-unittest}{unittest}: The unittest module of python was used to test the algorithms and the solver classes. These classes were complex and depended on a number of other classes
	\item \href{https://docs.pytest.org/en/latest/}{pytest}: Pytest was used for the tests of input modules, such as domain, obstacles and shapes. As these objects were fairly simple and had similar functionalities, it was best to write simple tests to expose edge cases.
\end{enumerate}
The key takeaways were:
\begin{enumerate}
\item The tests helped us communicate our ideas for individual classes clearly. The tests explicitly detailed what were the expected functionalities of each class. If an improvement was required, it was easy to communicate to the relevant person.
\item Initially, it was easy to skip the testing and go ahead with adding functionalities to the code as it was our first real attempt at test driven software development. Over time however, the process became more streamlined.
\end{enumerate}
\subsection{Travis}
To deploy continuous integration \href{https://travis-ci.com}{Travis} was the platform of choice. The tests were run using python versions 3.6 to 3.8-dev. This was added much later in the project stage as we were not able to add it to the private repository under the Princeton University organization. Through email communications, it appeared that any repository admin should be able to add Travis but finally it was realized that one of Princeton University organization admin has to manually add the repository. This delayed the continuous integration process for the project.